<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ—Ç—ã - —Ç—Ä–∏ –≤ —Ä—è–¥</title>
    <style>
        :root {
            --bg-primary: #f0f4f8;
            --bg-secondary: #ffffff;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --border-color: #cbd5e0;
            --accent: #667eea;
            --accent-dark: #5a67d8;
            --shadow: rgba(0, 0, 0, 0.1);
            --gem-1: #FF0000;
            --gem-2: #FF8800;
            --gem-3: #FFFF00;
            --gem-4: #00FF00;
            --gem-5: #00FFFF;
            --gem-6: #0000FF;
            --gem-7: #8800FF;
        }

        .dark {
            --bg-primary: #1a202c;
            --bg-secondary: #2d3748;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --border-color: #4a5568;
            --accent: #7c3aed;
            --accent-dark: #6d28d9;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            transition: background 0.3s ease, color 0.3s ease;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .dark h1 {
            background: linear-gradient(135deg, #a78bfa 0%, #c084fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .score-board {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .score-item {
            background: var(--bg-secondary);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px var(--shadow);
            min-width: 120px;
            text-align: center;
        }

        .score-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
        }

        #game-container {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px var(--shadow);
            margin-bottom: 20px;
        }

        #game-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px var(--shadow);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow);
        }

        button:active {
            transform: translateY(0);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: 700;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        #message.show {
            opacity: 1;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .modal-message {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
        }

        .modal-btn-secondary {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .floating {
            animation: float 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <header>
        <h1>üî∂ –ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ—Ç—ã üî∂</h1>
        <p style="color: var(--text-secondary); font-size: 1.1rem;">–°–æ–±–µ—Ä–∏—Ç–µ —Ç—Ä–∏ –≤ —Ä—è–¥!</p>
    </header>

    <div class="score-board">
        <div class="score-item" id="player-score-card">
            <div class="score-label">–í–∞—à–∏ –æ—á–∫–∏</div>
            <div class="score-value" id="score">0</div>
        </div>
        <div class="score-item" id="bot-score-card" style="display: none;">
            <div class="score-label">–û—á–∫–∏ –±–æ—Ç–∞</div>
            <div class="score-value" id="bot-score">0</div>
        </div>
        <div class="score-item" id="moves-card">
            <div class="score-label">–•–æ–¥–æ–≤</div>
            <div class="score-value" id="moves">30</div>
        </div>
        <div class="score-item" id="turn-indicator" style="display: none;">
            <div class="score-label">–•–æ–¥</div>
            <div class="score-value" id="current-turn">–í–∞—à</div>
        </div>
    </div>

    <div id="game-container">
        <svg id="game-canvas" width="600" height="650" viewBox="0 0 600 650"></svg>
        <div id="message"></div>
    </div>

    <div class="controls">
        <button onclick="game.toggleMode()">
            <span id="mode-btn-text">ü§ñ –ò–≥—Ä–∞—Ç—å —Å –±–æ—Ç–æ–º</span>
        </button>
        <button onclick="game.restart()">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button onclick="game.hint()" id="hint-btn">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
    </div>

    <div id="modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title" id="modal-title">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</div>
            <div class="modal-message" id="modal-message">–í–∞—à —Å—á–µ—Ç: 0</div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="modal-confirm">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>
                <button class="modal-btn modal-btn-secondary" id="modal-cancel">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>
    </div>

    <script>
        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–º–Ω–æ–π —Ç–µ–º—ã
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        class HexGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.hexRadius = 35;
                this.rows = 9;
                this.cols = 8;
                this.colors = ['#FF0000', '#FF8800', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#8800FF'];
                this.grid = [];
                this.oldPositions = {}; // –î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö –ø–æ–∑–∏—Ü–∏–π –ø—Ä–∏ –∞–Ω–∏–º–∞—Ü–∏–∏
                this.selected = null;
                this.score = 0;
                this.botScore = 0;
                this.moves = 30;
                this.isAnimating = false;
                this.vsBot = false; // –†–µ–∂–∏–º –∏–≥—Ä—ã —Å –±–æ—Ç–æ–º
                this.playerTurn = true; // –ß–µ–π —Ö–æ–¥ (true = –∏–≥—Ä–æ–∫, false = –±–æ—Ç)

                this.init();
            }

            init() {
                this.createGrid();
                this.render();
                this.setupEventListeners();
                // –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
                while (this.findMatches().length > 0) {
                    this.createGrid();
                }
                this.render();
            }

            createGrid() {
                this.grid = [];
                for (let row = 0; row < this.rows; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.cols; col++) {
                        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≥–µ–∫—Å—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ—Ç–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
                        if (row % 2 === 1 && col === this.cols - 1) continue;
                        this.grid[row][col] = {
                            color: this.randomColor(),
                            row: row,
                            col: col
                        };
                    }
                }
            }

            randomColor() {
                return this.colors[Math.floor(Math.random() * this.colors.length)];
            }

            getHexPosition(row, col) {
                const width = Math.sqrt(3) * this.hexRadius;
                const height = 2 * this.hexRadius;
                const vertDist = height * 0.75;

                let x = 50 + col * width;
                let y = 50 + row * vertDist;

                // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –Ω–µ—á–µ—Ç–Ω—ã—Ö —Ä—è–¥–æ–≤
                if (row % 2 === 1) {
                    x += width / 2;
                }

                return { x, y };
            }

            drawHexagon(x, y, color, selected = false, oldY = null) {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –Ω–∞ 30 –≥—Ä–∞–¥—É—Å–æ–≤ (Math.PI / 6)
                    const angle = (Math.PI / 3) * i + (Math.PI / 6);
                    const px = x + this.hexRadius * Math.cos(angle);
                    const py = y + this.hexRadius * Math.sin(angle);
                    points.push(`${px},${py}`);
                }

                const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hex.setAttribute('points', points.join(' '));
                hex.setAttribute('fill', color);
                hex.setAttribute('stroke', selected ? '#ffffff' : '#2d3748');
                hex.setAttribute('stroke-width', selected ? '4' : '2');
                hex.setAttribute('opacity', '0.9');
                hex.style.cursor = 'pointer';

                // –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è
                if (oldY !== null && oldY !== y) {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const offsetY = oldY - y;

                    group.appendChild(hex);
                    group.style.transform = `translateY(${offsetY}px)`;
                    group.style.transition = 'transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';

                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –≤ —Å–ª–µ–¥—É—é—â–µ–º –∫–∞–¥—Ä–µ
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            group.style.transform = 'translateY(0)';
                        });
                    });

                    return group;
                }

                return hex;
            }

            render(animate = false) {
                // –û—á–∏—â–∞–µ–º canvas
                while (this.canvas.firstChild) {
                    this.canvas.removeChild(this.canvas.firstChild);
                }

                // –†–∏—Å—É–µ–º –≤—Å–µ –≥–µ–∫—Å—ã
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = this.grid[row][col];
                        if (!cell) continue;

                        const pos = this.getHexPosition(row, col);
                        const key = `${row},${col}`;
                        const oldY = animate && this.oldPositions[key] ? this.oldPositions[key] : null;

                        const isSelected = this.selected &&
                            this.selected.row === row &&
                            this.selected.col === col;

                        const hex = this.drawHexagon(pos.x, pos.y, cell.color, isSelected, oldY);

                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º dataset –Ω–∞ —Å–∞–º polygon –∏–ª–∏ –Ω–∞ group
                        if (hex.tagName === 'g') {
                            hex.querySelector('polygon').dataset.row = row;
                            hex.querySelector('polygon').dataset.col = col;
                        } else {
                            hex.dataset.row = row;
                            hex.dataset.col = col;
                        }

                        this.canvas.appendChild(hex);
                    }
                }

                // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ—Å–ª–µ —Ä–µ–Ω–¥–µ—Ä–∞
                if (animate) {
                    this.oldPositions = {};
                }

                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç
                document.getElementById('score').textContent = this.score;
                document.getElementById('bot-score').textContent = this.botScore;
                document.getElementById('moves').textContent = this.moves;

                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ö–æ–¥–∞
                if (this.vsBot) {
                    const turnText = this.playerTurn ? '–í–∞—à' : '–ë–æ—Ç';
                    document.getElementById('current-turn').textContent = turnText;

                    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
                    const playerCard = document.getElementById('player-score-card');
                    const botCard = document.getElementById('bot-score-card');

                    if (this.playerTurn) {
                        playerCard.style.boxShadow = '0 0 20px var(--accent)';
                        botCard.style.boxShadow = '0 4px 6px var(--shadow)';
                    } else {
                        botCard.style.boxShadow = '0 0 20px var(--accent)';
                        playerCard.style.boxShadow = '0 4px 6px var(--shadow)';
                    }
                }
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.isAnimating) return;

                    // –í —Ä–µ–∂–∏–º–µ —Å –±–æ—Ç–æ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á–µ–π —Ö–æ–¥
                    if (this.vsBot && !this.playerTurn) {
                        this.showMessage('–°–µ–π—á–∞—Å —Ö–æ–¥ –±–æ—Ç–∞!');
                        return;
                    }

                    const hex = e.target;
                    if (!hex.dataset.row) return;

                    const row = parseInt(hex.dataset.row);
                    const col = parseInt(hex.dataset.col);

                    if (!this.selected) {
                        this.selected = { row, col };
                        this.render();
                    } else {
                        if (this.selected.row === row && this.selected.col === col) {
                            this.selected = null;
                            this.render();
                        } else if (this.areNeighbors(this.selected, { row, col })) {
                            this.swap(this.selected, { row, col });
                        } else {
                            this.selected = { row, col };
                            this.render();
                        }
                    }
                });
            }

            areNeighbors(hex1, hex2) {
                const neighbors = this.getNeighbors(hex1.row, hex1.col);
                return neighbors.some(n => n.row === hex2.row && n.col === hex2.col);
            }

            getNeighbors(row, col) {
                const neighbors = [];
                const isOddRow = row % 2 === 1;

                // 6 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –¥–ª—è –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–∏
                const offsets = isOddRow ? [
                    [0, 1],   // right
                    [1, 1],   // down-right
                    [1, 0],   // down-left
                    [0, -1],  // left
                    [-1, 0],  // up-left
                    [-1, 1]   // up-right
                ] : [
                    [0, 1],   // right
                    [1, 0],   // down-right
                    [1, -1],  // down-left
                    [0, -1],  // left
                    [-1, -1], // up-left
                    [-1, 0]   // up-right
                ];

                for (const [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (newRow >= 0 && newRow < this.rows &&
                        newCol >= 0 && newCol < this.cols &&
                        this.grid[newRow][newCol]) {
                        neighbors.push({ row: newRow, col: newCol });
                    }
                }

                return neighbors;
            }

            swap(hex1, hex2) {
                this.isAnimating = true;

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–≥–æ –æ–±–º–µ–Ω–∞
                const pos1 = this.getHexPosition(hex1.row, hex1.col);
                const pos2 = this.getHexPosition(hex2.row, hex2.col);

                // –ê–Ω–∏–º–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                const elements1 = this.canvas.querySelectorAll(`[data-row="${hex1.row}"][data-col="${hex1.col}"]`);
                const elements2 = this.canvas.querySelectorAll(`[data-row="${hex2.row}"][data-col="${hex2.col}"]`);

                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;

                elements1.forEach(el => {
                    const parent = el.closest('g') || el;
                    parent.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    parent.style.transform = `translate(${dx}px, ${dy}px)`;
                });

                elements2.forEach(el => {
                    const parent = el.closest('g') || el;
                    parent.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    parent.style.transform = `translate(${-dx}px, ${-dy}px)`;
                });

                setTimeout(() => {
                    // –ú–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
                    const temp = this.grid[hex1.row][hex1.col].color;
                    this.grid[hex1.row][hex1.col].color = this.grid[hex2.row][hex2.col].color;
                    this.grid[hex2.row][hex2.col].color = temp;

                    this.selected = null;
                    this.render();

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
                    const matches = this.findMatches();
                    if (matches.length > 0) {
                        if (!this.vsBot) {
                            this.moves--;
                        }
                        this.processMatches(matches);
                    } else {
                        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
                        setTimeout(() => {
                            const elements1Return = this.canvas.querySelectorAll(`[data-row="${hex1.row}"][data-col="${hex1.col}"]`);
                            const elements2Return = this.canvas.querySelectorAll(`[data-row="${hex2.row}"][data-col="${hex2.col}"]`);

                            elements1Return.forEach(el => {
                                const parent = el.closest('g') || el;
                                parent.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                                parent.style.transform = `translate(${-dx}px, ${-dy}px)`;
                            });

                            elements2Return.forEach(el => {
                                const parent = el.closest('g') || el;
                                parent.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                                parent.style.transform = `translate(${dx}px, ${dy}px)`;
                            });

                            setTimeout(() => {
                                const temp = this.grid[hex1.row][hex1.col].color;
                                this.grid[hex1.row][hex1.col].color = this.grid[hex2.row][hex2.col].color;
                                this.grid[hex2.row][hex2.col].color = temp;
                                this.render();
                                this.showMessage('–ù–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π!');
                                this.isAnimating = false;
                            }, 300);
                        }, 100);
                    }
                }, 300);
            }

            findMatches() {
                const visited = new Set();
                const allMatches = [];

                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –∫–ª–µ—Ç–∫–∞–º –∏ –∏—â–µ–º –≥—Ä—É–ø–ø—ã
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const key = `${row},${col}`;
                        const cell = this.grid[row][col];

                        if (!cell || !cell.color || visited.has(key)) continue;

                        // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Å–æ–ø—Ä–∏–∫–∞—Å–∞—é—â–∏–µ—Å—è –∫–ª–µ—Ç–∫–∏ —Ç–æ–≥–æ –∂–µ —Ü–≤–µ—Ç–∞ (BFS)
                        const group = this.findConnectedGroup(row, col, cell.color, visited);

                        // –ï—Å–ª–∏ –≥—Ä—É–ø–ø–∞ –∏–∑ 3 –∏–ª–∏ –±–æ–ª–µ–µ –∫–ª–µ—Ç–æ–∫ - –¥–æ–±–∞–≤–ª—è–µ–º –∫ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è–º
                        if (group.length >= 3) {
                            allMatches.push(...group);
                        }
                    }
                }

                return allMatches;
            }

            findConnectedGroup(startRow, startCol, color, visited) {
                const group = [];
                const queue = [{ row: startRow, col: startCol }];
                const localVisited = new Set();

                while (queue.length > 0) {
                    const current = queue.shift();
                    const key = `${current.row},${current.col}`;

                    if (localVisited.has(key)) continue;
                    localVisited.add(key);
                    visited.add(key);

                    const cell = this.grid[current.row][current.col];
                    if (!cell || cell.color !== color) continue;

                    group.push(current);

                    // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π —Ç–æ–≥–æ –∂–µ —Ü–≤–µ—Ç–∞ –≤ –æ—á–µ—Ä–µ–¥—å
                    const neighbors = this.getNeighbors(current.row, current.col);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborCell = this.grid[neighbor.row][neighbor.col];

                        if (!localVisited.has(neighborKey) &&
                            neighborCell &&
                            neighborCell.color === color) {
                            queue.push(neighbor);
                        }
                    }
                }

                return group;
            }

            processMatches(matches) {
                this.isAnimating = true;

                // –ù–∞—á–∏—Å–ª—è–µ–º –æ—á–∫–∏ —Ç–µ–∫—É—â–µ–º—É –∏–≥—Ä–æ–∫—É
                const points = matches.length * 10;
                if (this.vsBot) {
                    if (this.playerTurn) {
                        this.score += points;
                    } else {
                        this.botScore += points;
                    }
                } else {
                    this.score += points;
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è - –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —É–¥–∞–ª—è–µ–º—ã–µ –∫–ª–µ—Ç–∫–∏
                matches.forEach(match => {
                    const key = `${match.row},${match.col}`;
                    const elements = this.canvas.querySelectorAll(`[data-row="${match.row}"][data-col="${match.col}"]`);
                    elements.forEach(el => {
                        el.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        el.style.opacity = '0';
                        el.style.transform = 'scale(0.5)';
                    });
                });

                setTimeout(() => {
                    // –£–¥–∞–ª—è–µ–º —Å–æ–≤–ø–∞–≤—à–∏–µ
                    matches.forEach(match => {
                        this.grid[match.row][match.col].color = null;
                    });

                    this.render();
                }, 300);

                setTimeout(() => {
                    this.dropGems();
                    this.fillEmpty();
                    this.render(true); // –í–∫–ª—é—á–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–∞–¥–µ–Ω–∏—è

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
                    setTimeout(() => {
                        const newMatches = this.findMatches();
                        if (newMatches.length > 0) {
                            this.processMatches(newMatches);
                        } else {
                            this.isAnimating = false;

                            // –í —Ä–µ–∂–∏–º–µ —Å –±–æ—Ç–æ–º –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ö–æ–¥
                            if (this.vsBot) {
                                this.playerTurn = !this.playerTurn;
                                this.render();

                                // –ï—Å–ª–∏ —Ç–µ–ø–µ—Ä—å —Ö–æ–¥ –±–æ—Ç–∞, –¥–∞–µ–º –µ–º—É –ø–æ–¥—É–º–∞—Ç—å
                                if (!this.playerTurn) {
                                    setTimeout(() => {
                                        this.botMove();
                                    }, 1000);
                                }
                            } else {
                                this.checkGameOver();
                            }
                        }
                    }, 500); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
                }, 300);
            }

            dropGems() {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
                this.oldPositions = {};

                for (let col = 0; col < this.cols; col++) {
                    for (let row = this.rows - 1; row >= 0; row--) {
                        const cell = this.grid[row][col];
                        if (!cell) continue;

                        if (cell.color === null) {
                            // –ò—â–µ–º –≥–µ–º –≤—ã—à–µ
                            for (let r = row - 1; r >= 0; r--) {
                                if (this.grid[r][col] && this.grid[r][col].color !== null) {
                                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –ø–æ–∑–∏—Ü–∏—é Y –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
                                    const oldPos = this.getHexPosition(r, col);
                                    const newKey = `${row},${col}`;
                                    this.oldPositions[newKey] = oldPos.y;

                                    cell.color = this.grid[r][col].color;
                                    this.grid[r][col].color = null;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            fillEmpty() {
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = this.grid[row][col];
                        if (cell && cell.color === null) {
                            cell.color = this.randomColor();

                            // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –∫–ª–µ—Ç–æ–∫ —Å–≤–µ—Ä—Ö—É
                            const pos = this.getHexPosition(row, col);
                            const key = `${row},${col}`;
                            // –ù–æ–≤—ã–µ –∫–ª–µ—Ç–∫–∏ "–ø–∞–¥–∞—é—Ç" —Å –≤–µ—Ä—Ö–∞ —ç–∫—Ä–∞–Ω–∞
                            this.oldPositions[key] = pos.y - 150;
                        }
                    }
                }
            }

            botMove() {
                if (this.isAnimating) return;

                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
                const possibleMoves = this.findAllPossibleMoves();

                if (possibleMoves.length === 0) {
                    this.showMessage('–£ –±–æ—Ç–∞ –Ω–µ—Ç —Ö–æ–¥–æ–≤!');
                    this.playerTurn = true;
                    this.render();
                    return;
                }

                // –í—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–∏–π —Ö–æ–¥ (—Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π)
                possibleMoves.sort((a, b) => b.matchCount - a.matchCount);
                const bestMove = possibleMoves[0];

                // –î–µ–ª–∞–µ–º —Ö–æ–¥
                this.showMessage('–ë–æ—Ç –¥—É–º–∞–µ—Ç...');
                setTimeout(() => {
                    this.swap(bestMove.from, bestMove.to);
                }, 500);
            }

            findAllPossibleMoves() {
                const moves = [];

                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = this.grid[row][col];
                        if (!cell) continue;

                        const neighbors = this.getNeighbors(row, col);
                        for (const neighbor of neighbors) {
                            // –í—Ä–µ–º–µ–Ω–Ω–æ –º–µ–Ω—è–µ–º
                            const temp = this.grid[row][col].color;
                            this.grid[row][col].color = this.grid[neighbor.row][neighbor.col].color;
                            this.grid[neighbor.row][neighbor.col].color = temp;

                            const matches = this.findMatches();
                            if (matches.length > 0) {
                                moves.push({
                                    from: { row, col },
                                    to: neighbor,
                                    matchCount: matches.length
                                });
                            }

                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
                            this.grid[neighbor.row][neighbor.col].color = this.grid[row][col].color;
                            this.grid[row][col].color = temp;
                        }
                    }
                }

                return moves;
            }

            toggleMode() {
                this.vsBot = !this.vsBot;

                // –û–±–Ω–æ–≤–ª—è–µ–º UI
                const modeBtnText = document.getElementById('mode-btn-text');
                const botScoreCard = document.getElementById('bot-score-card');
                const turnIndicator = document.getElementById('turn-indicator');
                const movesCard = document.getElementById('moves-card');
                const hintBtn = document.getElementById('hint-btn');
                const playerScoreLabel = document.querySelector('#player-score-card .score-label');

                if (this.vsBot) {
                    modeBtnText.textContent = 'üë§ –û–¥–∏–Ω–æ—á–Ω–∞—è –∏–≥—Ä–∞';
                    botScoreCard.style.display = 'block';
                    turnIndicator.style.display = 'block';
                    movesCard.style.display = 'none';
                    hintBtn.style.display = 'none';
                    playerScoreLabel.textContent = '–í–∞—à–∏ –æ—á–∫–∏';
                } else {
                    modeBtnText.textContent = 'ü§ñ –ò–≥—Ä–∞—Ç—å —Å –±–æ—Ç–æ–º';
                    botScoreCard.style.display = 'none';
                    turnIndicator.style.display = 'none';
                    movesCard.style.display = 'block';
                    hintBtn.style.display = 'inline-block';
                    playerScoreLabel.textContent = '–û—á–∫–∏';
                }

                this.restart();
            }

            checkGameOver() {
                if (this.vsBot) {
                    // –í —Ä–µ–∂–∏–º–µ —Å –±–æ—Ç–æ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ö–æ–¥–æ–≤
                    const possibleMoves = this.findAllPossibleMoves();
                    if (possibleMoves.length === 0) {
                        const winner = this.score > this.botScore ? '–í—ã –ø–æ–±–µ–¥–∏–ª–∏!' :
                                      this.score < this.botScore ? '–ë–æ—Ç –ø–æ–±–µ–¥–∏–ª!' : '–ù–∏—á—å—è!';
                        this.showMessage(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! ${winner}`);
                        setTimeout(() => {
                            this.showGameOverModal(winner);
                        }, 1000);
                    }
                } else {
                    if (this.moves <= 0) {
                        this.showMessage(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á–µ—Ç: ${this.score}`);
                        setTimeout(() => {
                            this.showGameOverModal();
                        }, 1000);
                    }
                }
            }

            showGameOverModal(winner = null) {
                const modal = document.getElementById('modal');
                const modalTitle = document.getElementById('modal-title');
                const modalMessage = document.getElementById('modal-message');
                const confirmBtn = document.getElementById('modal-confirm');
                const cancelBtn = document.getElementById('modal-cancel');

                if (this.vsBot && winner) {
                    modalTitle.textContent = winner;
                    modalMessage.textContent = `–í–∞—à–∏ –æ—á–∫–∏: ${this.score} | –û—á–∫–∏ –±–æ—Ç–∞: ${this.botScore}`;
                } else {
                    modalTitle.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!';
                    modalMessage.textContent = `–í–∞—à —Å—á–µ—Ç: ${this.score}`;
                }

                modal.classList.add('show');

                const handleConfirm = () => {
                    modal.classList.remove('show');
                    this.restart();
                    cleanup();
                };

                const handleCancel = () => {
                    modal.classList.remove('show');
                    cleanup();
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);
            }

            hint() {
                // –ü—Ä–æ—Å—Ç–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ - –Ω–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤—ã–π –≤–æ–∑–º–æ–∂–Ω—ã–π —Ö–æ–¥
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = this.grid[row][col];
                        if (!cell) continue;

                        const neighbors = this.getNeighbors(row, col);
                        for (const neighbor of neighbors) {
                            // –í—Ä–µ–º–µ–Ω–Ω–æ –º–µ–Ω—è–µ–º
                            const temp = this.grid[row][col].color;
                            this.grid[row][col].color = this.grid[neighbor.row][neighbor.col].color;
                            this.grid[neighbor.row][neighbor.col].color = temp;

                            if (this.findMatches().length > 0) {
                                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
                                this.grid[neighbor.row][neighbor.col].color = this.grid[row][col].color;
                                this.grid[row][col].color = temp;

                                this.showMessage(`–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ä—è–¥ ${row + 1}, –∫–æ–ª–æ–Ω–∫—É ${col + 1}!`);
                                return;
                            }

                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
                            this.grid[neighbor.row][neighbor.col].color = this.grid[row][col].color;
                            this.grid[row][col].color = temp;
                        }
                    }
                }
                this.showMessage('–•–æ–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
            }

            showMessage(text) {
                const msg = document.getElementById('message');
                msg.textContent = text;
                msg.classList.add('show');
                setTimeout(() => {
                    msg.classList.remove('show');
                }, 2000);
            }

            restart() {
                this.score = 0;
                this.botScore = 0;
                this.moves = 30;
                this.selected = null;
                this.isAnimating = false;
                this.playerTurn = true;

                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –∫–∞—Ä—Ç–æ—á–µ–∫
                const playerCard = document.getElementById('player-score-card');
                const botCard = document.getElementById('bot-score-card');
                playerCard.style.boxShadow = '0 4px 6px var(--shadow)';
                botCard.style.boxShadow = '0 4px 6px var(--shadow)';

                this.createGrid();
                while (this.findMatches().length > 0) {
                    this.createGrid();
                }
                this.render();

                const message = this.vsBot ? '–ù–æ–≤–∞—è –∏–≥—Ä–∞! –í–∞—à —Ö–æ–¥!' : '–ù–æ–≤–∞—è –∏–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞!';
                this.showMessage(message);
            }
        }

        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        const game = new HexGame();
    </script>
</body>
</html>
